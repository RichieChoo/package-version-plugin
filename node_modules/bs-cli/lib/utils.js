/**
 *
 * @author RichieChoo
 * @description 工具函数
 *
 */

const fs = require('fs');
const path = require('path');
const exec = require('child_process').exec;
var validator = require('validator');
const config = require('./constant');
const converter = require('number-to-words');
const chalk = require('chalk');
const log = require('./fancy-log');

//resolve parameter for master or publish
const resolveLength = (arg, type) => {
  if (arg.length !== 1) {
    if (arg.length === 0) {
      //master 非必填
      if (type === 'publish' || type === 'batch' || type === '-c') {
        log(
          chalk['red'](
            `Unexpected "${type}" parameter: can not get any "${type}"  parameter!`
          )
        );
        process.exit(1);
      }
    } else {
      log(
        chalk['red'](
          `Unexpected "${type}"  parameter: expected one "${type}"  parameter, but got ${converter.toWords(
            arg.length
          )}!`
        )
      );
      process.exit(1);
    }
  }
};

//get arg arr for some flag
const getRangeFromArg = (arg, flag) => {
  const aotherFlag = '--';
  const beginIndex = arg.findIndex(v => v === flag);
  let result = [];
  let aotherIndex = -1;
  if (beginIndex === -1) {
    return result;
  } else {
    aotherIndex = arg.findIndex(
      (v, p) => v.includes(aotherFlag) && p > beginIndex
    );
    result = arg.slice(
      beginIndex + 1, // skip flag
      aotherIndex !== -1 ? aotherIndex : arg.length
    );
    return Array.from(new Set(result));
  }
};

const clearSpace = (currentPath, callback) => {
  exec(`cd ${currentPath} && git checkout .`, (error, stdout, stderr) => {
    if (!error) {
      log(chalk['blue'](`Find Error and clear bs publish trace!`));
      if (callback) callback();
    } else {
      log(
        chalk['red'](
          `Find Error but clear bs publish trace fail, please contact admin`
        )
      );
    }
  });
};

const getNewVersion = (package, versions, filterByFirstVersionNum) => {
  let resultVersion = false;
  if (versions.length === 0) return package.version;
  const bigVersion = package.version.split('.')[0];
  let newVersions = versions;
  if (filterByFirstVersionNum) {
    console.log("ok")
    newVersions = newVersions.filter(v => v.split('.')[0] === bigVersion);
  }
  if (!package.version) return resultVersion;
  if (newVersions.length === 0) {
    resultVersion = Number(bigVersion) + 1 + '.0.0';
  } else {
    resultVersion = newVersions[newVersions.length - 1];
  }
  return resultVersion;
};
exports = module.exports = {
  resolveLength,
  getRangeFromArg,
  clearSpace,
  getNewVersion,
};
