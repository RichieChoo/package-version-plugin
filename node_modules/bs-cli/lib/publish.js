const { resolveLength, getRangeFromArg } = require('./utils');

const fs = require('fs');
const path = require('path');
const logger = require('./logger');
const { getNewVersion } = require('./utils');
const exec = require('child_process').exec;
const validator = require('validator');
const config = require('./constant');

const buildMaster = ({ currentPath, master, beginTime, logPath }) => {
  //publishing quenes completed!
  function endCallBack() {
    exec(`cd ${currentPath} && git checkout .`, (error, stdout, stderr) => {
      if (!error) {
        logger.success(`Clear bs publish trace success!`, logPath);
        logger.success(
          `SUCCESS in ${(new Date() - beginTime) / 1000}s`,
          logPath,
          true
        );
      } else {
        logger.err(error, logPath);
      }
    });
  }

  if (master) {
    const masterPath = path.join(currentPath, master);
    ex;
    logger.success(
      `All publishing quenes completed! Installing dependencies for "${master}"`,
      logPath
    );
    exec(
      `cd ${masterPath} && npm install &&  npm update`,
      (error, stdout, stderr) => {
        if (!error) {
          logger.success(`Installed! Building "${master}"`);
          exec(
            `cd ${masterPath} && rm -rf dist && npm run build`,
            { maxBuffer: 5000 * 1024 },
            (error, stdout, stderr) => {
              if (!error) {
                endCallBack();
              } else {
                logger.err(
                  `Executed command "cd ${masterPath} && npm run build" fail! \n\n${error}`,
                  logPath
                );
              }
            }
          );
        } else {
          logger.err(
            `Executed command "cd ${masterPath} && npm install &&  npm update" fail! \n\n${error}`,
            logPath
          );
        }
      }
    );
  } else {
    endCallBack();
  }
};

//batch publish for a quene
const publishQuene = ({
  currentPath,
  quene,
  queneIndex,
  logPath,
  isFullInstall,
  callback,
}) => {
  if (quene.length === 0) {
    callback();
  } else {
    let scsNum = 0;
    logger.success(
      `Get ${queneIndex} publishing quene: "${quene.toString()}"`,
      logPath
    );
    quene.forEach(item => {
      const itemPath = path.join(currentPath, item);
      const itemPackagePath = path.join(itemPath, 'package.json');
      fs.readFile(itemPackagePath, (err, data) => {
        if (!err) {
          if (validator.isJSON(data.toString())) {
            const itemPackage = JSON.parse(data.toString());
            const install = isFullInstall
              ? 'rm -rf dist node_modules && npm install'
              : 'rm -rf dist && npm install && npm update';
            const bash = {
              install: `cd ${itemPath} && ${install}`,
              build: `cd ${itemPath} && npm run build:lib`,
              getLatest: `cd ${itemPath} && npm view ${itemPackage.name} versions --json`,
              versionPatch: `cd ${itemPath} && npm version --no-git-tag-version patch`,
              publish: `cd ${itemPath} && npm publish`,
            };
            logger.success(`Installing dependencies for "${item}"`, logPath);

            //install
            exec(
              bash.install,
              { maxBuffer: 5000 * 1024 },
              (error, stdout, stderr) => {
                if (!error) {
                  logger.success(`Installed! Building "${item}"`, logPath);

                  //build
                  exec(
                    bash.build,
                    { maxBuffer: 5000 * 1024 },
                    (error, stdout, stderr) => {
                      if (!error) {
                        logger.success(
                          `Builded! Publishing "${itemPackage.name}"`,
                          logPath
                        );

                        // publish
                        // get latest version of item
                        exec(bash.getLatest, (error, stdout, stderr) => {
                          if (!error) {
                            //npm view version will sort the version array
                            const versions = JSON.parse(
                              stdout.replace(/(\r\n\t|\n|\r\t)/gm, '')
                            );
                            if (versions.length === 0) {
                              logger.err(
                                `Not Exists: Can not find ${itemPackage.name} in current npm registry`,
                                logPath
                              );
                            }
                            const newVersion = getNewVersion(
                              itemPackage,
                              versions,
                            );
                            if (!newVersion) {
                              logger.err(
                                `Not Exists: Can not find version in '${packagePath}'`
                              );
                            }
                            itemPackage.version = newVersion;
                            const result = JSON.stringify(itemPackage, null, 2);
                            fs.writeFile(itemPackagePath, result, err => {
                              if (!err) {
                                //npm version patch
                                exec(
                                  bash.versionPatch,
                                  (error, stdout, stderr) => {
                                    if (!error) {
                                      const newVersion = stdout.replace(
                                        /(\r\n\t|\n|\r\t|v)/gm,
                                        ''
                                      );
                                      exec(
                                        bash.publish,
                                        (error, stdout, stderr) => {
                                          if (!error) {
                                            logger.success(
                                              `Published "${itemPackage.name}@${newVersion}"!`,
                                              logPath
                                            );
                                            scsNum += 1;
                                            if (scsNum === quene.length) {
                                              logger.success(
                                                `The ${queneIndex} publishing quene "${quene.toString()}" completed!`,
                                                logPath
                                              );
                                              callback();
                                            }
                                          } else {
                                            logger.err(
                                              `Executed command "${bash.publish}" fail! \n\n${error}`,
                                              logPath
                                            );
                                          }
                                        }
                                      );
                                    } else {
                                      logger.err(
                                        `Executed command "${bash.versionPatch}" fail! \n\n${error}`,
                                        logPath
                                      );
                                    }
                                  }
                                );
                              } else {
                                logger.err(
                                  `Write "${itemPackage.name}" latest version fail !\n\nFile path: "${itemPackagePath}"]"`,
                                  logPath
                                );
                              }
                            });
                          } else {
                            logger.err(
                              `Executed command "${bash.getLatest}" fail! \n\n${error}`,
                              logPath
                            );
                          }
                        });
                      } else {
                        logger.err(
                          `Executed command "${bash.build}" fail! \n\n${error}`,
                          logPath
                        );
                      }
                    }
                  );
                } else {
                  logger.err(
                    `Executed command "${bash.install}" fail! \n\n${error}`,
                    logPath
                  );
                }
              }
            );
          } else {
            logger.err(
              `Not JSON: "${itemPackagePath}" is not a right json file`,
              logPath
            );
          }
        } else {
          logger.err(err, logPath);
        }
      });
    });
  }
};

//create quene from a path
const publishJob = ({
  currentPath,
  firstArg,
  logPath,
  filterArr,
  master,
  isFullInstall,
}) => {
  let beginTime = new Date();
  let files = fs.readdirSync(currentPath);
  filterArr.forEach(v => {
    if (v === master) {
      logger.success(`Get master "${v}"`, logPath);
    } else {
      logger.success(`Get except folder "${v}"`, logPath);
    }
  });

  //Get folder list and filter the folder which not contain a package.json
  const resolveArr = files.filter(item => {
    const itemPath = path.join(currentPath, item);
    const itemPackagePath = path.join(itemPath, 'package.json');
    return (
      fs.statSync(itemPath).isDirectory() &&
      fs.existsSync(itemPackagePath) &&
      !filterArr.includes(item)
    );
  });
  if (resolveArr.length === 0) {
    logger.err(
      `Not Found: "${currentPath}" not contains any package folder`,
      logPath
    );
  }

  //get first quene
  const firstQuene = firstArg.map(v => {
    if (resolveArr.includes(v)) {
      return v;
    } else {
      if (filterArr.includes(v)) {
        logger.err(
          `Unexpected options, "--except" option contains "${v}", please check "--first" option`,
          logPath
        );
      } else {
        logger.err(
          `"${currentPath}" not contains "${v}", please check "--first" option`,
          logPath
        );
      }
    }
  });

  //get second quene
  const secondQuene = resolveArr.filter(v => !firstQuene.includes(v));

  //publish second quene
  function publishSecondQuene() {
    publishQuene({
      currentPath,
      quene: secondQuene,
      queneIndex: 'second',
      logPath,
      isFullInstall,
      callback: () => buildMaster({ currentPath, master, beginTime, logPath }),
    });
  }

  //publish quene
  publishQuene({
    currentPath,
    quene: firstQuene,
    queneIndex: 'first',
    logPath,
    isFullInstall,
    callback: publishSecondQuene,
  });
};

module.exports = arg => {
  let currentPath = process.cwd();
  let isExist;
  let filterArr = [];
  let gitPull = 'git pull';
  const publishArg = getRangeFromArg(arg, 'publish');

  //master will build after all publish list completed
  const masterArg = getRangeFromArg(arg, '--master');
  const firstArg = getRangeFromArg(arg, '--first');
  resolveLength(publishArg, 'publish');
  resolveLength(masterArg, '--master');
  currentPath = publishArg[0];
  let master = masterArg[0];
  if (master && !fs.existsSync(path.join(currentPath, master))) {
    logger.err(
      `Unexpected "--master" parameter: "${currentPath}" not contains folder "${master}"`
    );
  }
  if (!currentPath) {
    isExist = false;
  } else if (path.isAbsolute(currentPath)) {
    isExist = true;
  } else {
    currentPath = path.resolve(currentPath);
    try {
      isExist = fs.statSync(currentPath).isDirectory();
    } catch (error) {
      isExist = false;
      logger.err(`Not Exist Folder: "${currentPath}"`);
    }
  }

  if (isExist) {
    const logPath = path.join(currentPath, config.logPath);
    const gitBranchArg = getRangeFromArg(arg, '--git-pull-parameter');
    const isFullInstall = arg.findIndex(v => v === '--full-install') !== -1;
    const noGit = arg.findIndex(v => v === '--no-git') !== -1;
    gitPull = noGit ? false : [gitPull, ...gitBranchArg].join(' ');

    //master will be joined to the unpublish filterArr
    filterArr = Array.from(
      new Set([...getRangeFromArg(arg, '--except'), ...masterArg])
    );

    //Add a tap between logs
    logger.success('', logPath);
    logger.success(`Get work path "${currentPath}"`, logPath);

    if (gitPull) {
      //check whether is a git repository
      exec(
        `cd ${currentPath} && git rev-parse --is-inside-work-tree`,
        (error, stdout, stderr) => {
          if (!error) {
            logger.success(
              `Running '${gitPull}' for git repository '${currentPath}'`,
              logPath
            );
            exec(
              `cd ${currentPath} && git checkout . && ${gitPull}`,
              (error, stdout, stderr) => {
                if (!error) {
                  logger.success(stdout, logPath);
                  publishJob({
                    currentPath,
                    firstArg,
                    logPath,
                    filterArr,
                    master,
                    isFullInstall,
                  });
                } else {
                  logger.err(error);
                }
              }
            );
          } else {
            logger.success(
              `'${currentPath}' is not a git repository, bs will not run 'git pull' for it`,
              logPath
            );
            publishJob({
              currentPath,
              firstArg,
              logPath,
              filterArr,
              master,
              isFullInstall,
            });
          }
        }
      );
    } else {
      publishJob({
        currentPath,
        firstArg,
        logPath,
        filterArr,
        master,
        isFullInstall,
      });
    }
  }
};
